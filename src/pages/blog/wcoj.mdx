---
draft: true
token: '2323'
author: 'fin'
title: 'Worst-cast optimal join in Clojure'
description: 'Exploring new join algorithms for Datalog'
category: 'clojure'
layout: '../../layouts/BlogPost.astro'
publishedDate: '01 Dec 2022'
heroImage: 'river_lake.jpg'
tags:
  - 'clojure'
  - 'datalog'
---

import { Image } from '@astrojs/image/components'
import jointrees from '../../assets/blog/wcoj/join-trees.jpg'
import unaryjoin from '../../assets/blog/wcoj/unary-relation-join.png'

### Joins

Let's talk about joins. Imagine three relations (think tables in SQL and tuples in Datalog)
$R(a,b)$, $S(a,c)$, $T(b,c)$ and that we want to compute the join $R \Join S \Join T$. A common approach
in databases these days (and what for example Postgres does) is to join in a relation at a time.
This leads to the natural definition of a join tree.

<Image alt='image' width='500' src={jointrees} />

The problem with join trees is that you might do more work then needed in an intermediate join.
For example for the join tree on the left we are creating a 1000 rows/tuples although we are
only needing 100 at the end. The join tree on the right does much better in that regard as it
only realizes 10 intermediate results. So the difficulty when doing binary joins of relations is
finding a good join tree.

### Triangle query

The three relations don't need to be different relations they could all be the same. Imagine a
relation $G(a,b)$ (a graph) and the join $G(a,c) \Join G(a,b) \Join G(b,c)$. If you think of the
data in $G$ as edges, then the join computes the triangles in a graph. For completeness the
corresponding queries in SQL and Datalog.


```SQL
SELECT
    g1.f AS a, g1.t AS b, g2.t AS c
FROM
    g AS g1, g AS g2, g AS g3
WHERE
    g1.t = g2.f AND g2.t = g3.t AND g1.f = g3.f;
```

```clojure
'{:find [?a ?b ?c]
  :where [[?a :g/to ?b]
          [?a :g/to ?c]
          [?b :g/to ?c]]}
```

The triangle query is ominpresent when looking at the Worst-case optimal join (WCOJ henceforth)
literature and at the heart of the *WCOJ goldrush*. We are going to use it to illustrate what WCOJ is
all about.

The important part is that no graph can have more then $O(N^{3/2})$ triangles
(some hard math behind this) where
$N$ is the number of edges in the graph $G$ (or rows in the relation $G$). There are however
graphs where no matter how you choose to join the first two graphs
(essentially calculating 2-paths) you will end up with $O(N^2)$ intermediate rows.
In this case our binary join strategy above is essentially doomed. No matter what binary join tree you
choose you will have more intermediate output tuples then your final result. WCOJ is about
avoiding this unnessary work. A WCOJ algorithm calculates the above joins in $O(N^{3/2})$.

More generally if you fix some schema for you database and you fix some query over that schema then
there is exists some "Worst Case" output size ($O(N^{3/2})$ for the graph above
but more complicated for the general case as your relations might have different sizes)
for some instantiation of your database.
WCOJ guarantees you that you will do no more work then this worst-case output size.
Let's also mention what WCOJ is not. WCOJ does not give you any guarantees on
the runtime in the general case. So imagine a graph with a single triangle. A WCOJ algorithm
does not run in constant time, the only guarantee is a runtime of $O(N^{3/2})$ (although
in practice this preforms very likely better).

In the following sections we try to gradually build up all the necessary knowledge/manchinary for
building a WCOJ algorithm for a simple Datalog engine in Clojure.

### Set intersections

We are starting with a well known fact which is used extensively in Databases. The intersection
of two sets can be done efficiently in the size of the smaller set. By efficiently we mean $O(N)$ or
$O(N \log N)$ where $N$ is the size of the smaller set. You walk the items of the smaller set and
check if they exist in the larger set. You can even see this kind of algorithm at work in the `clojure.set`
[namespace](https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/clj/clojure/set.clj#L33-L47).

In databases data is often not stored in hash structures but rather B-trees which stores data sorted and
allow efficient seeking to some specific key. This seek operation is what brings in the extra $O(\log N)$ factor.
Let's take as an example a simple datalog query with a single variable.
```clj
'{:find [?x]
  :where [[?x :person/hometown "Berlin"]
          [?x :person/firstname "Bob"]
          [?x :person/eats "Spaghetti"]]}
```
So we are looking for a person living in Berlin, whose name is Bob and who eats Spaghetti. Assuming
for now that we have access to some iterator where each iterator satisfies the contstraints of the
specific `where` clause (people living in Berlin for the first one) and where the data is sorted while we iterate over it.
```clj
(defprotocol Iterator
  (first [this])
  (next [this])
  (seek [this k]))
```
The first two operations are just the ones we know from the Clojure Sequence abstraction. `seek` is the one we have
described above. If a key is not present in an iterator the seek operation seeks to the next element that is larger than
the given key. The joining of multiple iterators can then be done by keeping track of the largest head element (sorting by `first`)
of the iterators and trying to bring the iterator with the smallest head element to be at least as large as the largest (`seek`).
If the largest and the smallest head element of any iterator are equal we have found a match.

<Image alt='image' width='1000' src={unaryjoin} />

So imagine that we have three iterators $A$, $B$ and $C$ for our three `where` clauses above. The data of
these iterators is just integers (you can think of this as the hash of the actual values) so we can compare
elements. In on disk implementations you can also think of this as byte arrays of the actual data.

The clojure core standard `sorted-set` and `sorted-map` implementations do not provide any efficient
`seek` operation, but
[other](https://github.com/clojure/data.avl/commit/11f905b9b45d1873a2782066352126dd91f40af4)
[implementations](https://github.com/tonsky/persistent-sorted-set/pull/9/files) can be extended to support this.

### Iterators

### A simple datalog engine

### Abstracting more

Once you start implementing the algorithm outlined above you realize that it
quickly becomes very gnarly as there is the need for a lot of bookkeeping.
Whery am I currently for which operator

### Variable variable ordering

Why I like about the approach just outlined in the paragraph above.


### A (simplified) proof

So far I mainly talked about implementation details and but have not given you any "proof"
that what we have built so far actually works in the desired runtime.

### Final remarks

You can find some of the ideas explained above implemented (although rather poorly tested)
at the [following](https://github.com/FiV0/hooray) repository.

### Appendix (general Formula)

### References

- The [slides](https://slides.com/fiv0/deck) of a talk about WCOJ I gave at the local Berlin Clojure meetup.
- AGM bound [https://arxiv.org/pdf/1711.03860.pdf](https://arxiv.org/pdf/1711.03860.pdf). The paper is not itself about
WCOJ but contains the result about graphs that the triggered this whole research area.

The following are roughly in order of comprehensibility (modulo my subjectivity):
- [https://justinjaffray.com/a-gentle-ish-introduction-to-worst-case-optimal-joins/](https://justinjaffray.com/a-gentle-ish-introduction-to-worst-case-optimal-joins/)
- [http://www.frankmcsherry.org/dataflow/relational/join/2015/04/11/genericjoin.html](http://www.frankmcsherry.org/dataflow/relational/join/2015/04/11/genericjoin.html)
- Leapfrog Triejoin [https://arxiv.org/abs/1210.0481](https://arxiv.org/abs/1210.0481)
- Skew strikes back [https://arxiv.org/abs/1310.3314](https://arxiv.org/abs/1310.3314)
- Radix Triejoin [https://arxiv.org/abs/1912.12747](https://arxiv.org/abs/1912.12747)
- WCOJ review [https://arxiv.org/abs/1803.09930](https://arxiv.org/abs/1803.09930)
- Simpli-Squared [https://arxiv.org/abs/2111.00163](https://arxiv.org/abs/2111.00163)

- Lake/Mountain picture at the top from [Luca Bravo](https://unsplash.com/@lucabravo)
