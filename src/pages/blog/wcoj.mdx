---
draft: true
token: '2323'
author: 'fin'
title: 'Worst-cast optimal join in Clojure'
description: 'Exploring new join algorithms for Datalog'
category: 'clojure'
layout: '../../layouts/BlogPost.astro'
publishedDate: '01 Dec 2022'
heroImage: 'river_lake.jpg'
tags:
  - 'clojure'
  - 'datalog'
---

import { Image } from '@astrojs/image/components'
import jointrees from '../../assets/blog/wcoj/join-trees.jpg'
import unaryjoin from '../../assets/blog/wcoj/unary-relation-join.png'

### Joins

Let's talk about joins. Imagine three relations (think tables in SQL and tuples in Datalog)
$R(a,b)$, $S(a,c)$, $T(b,c)$ and that we want to compute the join $R \Join S \Join T$. A common approach
in databases these days (and what for example Postgres does) is to join in a relation at a time.
This leads to the natural definition of a join tree.

<Image alt='image' width='500' src={jointrees} />

The problem with join trees is that you might do more work then needed in an intermediate join.
For example for the join tree on the left we are creating a 1000 rows/tuples although we are
only needing 100 at the end. The join tree on the right does much better in that regard as it
only realizes 10 intermediate results. So the difficulty when doing binary joins of relations is
finding a good join tree.

### Triangle query

The three relations don't need to be different relations they could all be the same. Imagine a
relation $G(a,b)$ (a graph) and the join $G(a,c) \Join G(a,b) \Join G(b,c)$. If you think of the
data in $G$ as edges, then the join computes the triangles in a graph. For completeness the
corresponding queries in SQL and Datalog.


```SQL
SELECT
    g1.f AS a, g1.t AS b, g2.t AS c
FROM
    g AS g1, g AS g2, g AS g3
WHERE
    g1.t = g2.f AND g2.t = g3.t AND g1.f = g3.f;
```

```clojure
'{:find [?a ?b ?c]
  :where [[?a :g/to ?b]
          [?a :g/to ?c]
          [?b :g/to ?c]]}
```

The triangle query is ominpresent when looking at the Worst-case optimal join (WCOJ henceforth)
literature and at the heart of the *WCOJ goldrush*. We are going to use it to illustrate what WCOJ is
all about.

The important part is that no graph can have more then $O(N^{3/2})$ triangles
(some hard math behind this) where
$N$ is the number of edges in the graph $G$ (or rows in the relation $G$). There are however
graphs where no matter how you choose to join the first two graphs
(essentially calculating 2-paths) you will end up with $O(N^2)$ intermediate rows.
In this case the binary join strategy above is doomed. No matter what binary join tree you
choose you will have more intermediate output tuples then your final result. WCOJ is about
avoiding this unnessary work. A WCOJ algorithm calculates the above joins in $O(N^{3/2})$.

More generally if you fix some schema for you database (in the above `[integer :g/to integer]`) and you
fix some query over that schema (the triangle query) then
there is exists some "Worst Case" output size ($O(N^{3/2})$ for the graph above
but more complicated for the general case as your relations might have different sizes)
for some instantiation of your database.
WCOJ guarantees you that you will do no more work then this worst-case output size.
Let's also mention what WCOJ is not. WCOJ does not give you any guarantees on
the runtime based on the output size. So imagine a graph with a single triangle. A WCOJ algorithm
does not run in constant time, the only guarantee is a runtime of $O(N^{3/2})$ (although
in practice this preforms very likely better).

In the following sections we try to gradually build up all the necessary knowledge/manchinary for
building a WCOJ algorithm for a simple Datalog engine in Clojure.

### Set intersections

A well known fact which is used extensively in Databases is that the intersection
of two sets can be done efficiently in the size of the smaller set. By efficiently we mean $O(N)$ or
$O(N \log N)$ where $N$ is the size of the smaller set. You walk the items of the smaller set and
check if they exist in the larger set. You can even see this kind of algorithm at work in the `clojure.set`
[namespace](https://github.com/clojure/clojure/blob/5ffe3833508495ca7c635d47ad7a1c8b820eab76/src/clj/clojure/set.clj#L33-L47).

In databases data is often not stored in hash structures but rather B-trees which stores data sorted and
allow efficient seeking to some specific key. This seek operation is what brings in the extra $O(\log N)$ factor.
Let's take as an example a simple datalog query with a single variable.
```clj
'{:find [?x]
  :where [[?x :person/hometown "Berlin"]
          [?x :person/firstname "Bob"]
          [?x :person/eats "Spaghetti"]]}
```
So we are looking for a person living in Berlin, whose name is Bob and who eats Spaghetti. Assuming
for now that we have access to some iterator where each iterator satisfies the contstraints of the
specific `where` clause (people living in Berlin for the first one) and where the data is sorted while we iterate over it.
```clj
(defprotocol Iterator
  (first [this])
  (next [this])
  (seek [this k]))
```
The first two operations are just the ones we know from the Clojure Sequence abstraction. `seek` is the one we have
described above. If a key is not present in an iterator the seek operation seeks to the next element that is larger than
the given key. The joining of multiple iterators can then be done by keeping track of the largest head element (sorting by `first`)
of the iterators and trying to bring the iterator with the smallest head element to be at least as large as the largest (`seek`).
If the largest and the smallest head element of any iterator are equal we have found a match.

<Image alt='image' width='1000' src={unaryjoin} />

So imagine that we have three iterators $A$, $B$ and $C$ for our three `where` clauses above. The data of
these iterators is just integers (you can think of this as the hash of the actual values) so we can compare
elements. In an on disk implementations you can also think of this as byte arrays of the actual data.

The clojure core standard `sorted-set` and `sorted-map` implementations do not provide any efficient
`seek` operation, but
[other](https://github.com/clojure/data.avl/commit/11f905b9b45d1873a2782066352126dd91f40af4)
[implementations](https://github.com/tonsky/persistent-sorted-set/pull/9/files) can be extended to support this.

### Storage

Let's next look at how we are going to store our data. We are going split things into indices and a document-store.
The indices are permutations of `e`,`a` and `v` (standing for entity, attribute and value) and they are only
storing some hash of the entity, attribute, value which is all we need for joining the data. Later, once we
know which hashes we are actually interested in, we are going to fetch the actual values from the
`:doc-store` which is a mapping from hash to actual value. So the indices are going to be nested maps bottoming
out at a set.

You might be wondering why we are storing the hashes in the indices and not just the actual values.
The reason is twofold. As we want to use an implementaiton of a sorted-set the values need to be comparable
which hashes are. One could have ofcourse added the actual values to these sorted sets and used a hash comparator
underneath. The second reason is that if later on we might want to try a remote key/value store for our
indices it is nice to delay the fetching of the actual needed data as long as possible as network requests
will be expensive. In that case it makes sense to only fetch the hashes of the objects for the joins and
query for the data only if really needed.

All of this is way better illustrated by an example. Let's say we want to add the following triple to our engine:
```clj
[:db/add "Bob" :person/eats "Spaghetti"]
```
and for simplicity let's assume that the hashes for `"Bob"`,`:person/eats` and `"Spaghetti"` are 1,2 and 3 respectively. Then
having added the above fact to an empty database our indices would look as follows:
```clj
;; eav index
{1 {2 #{3}}}
;; aev index
{2 {1 #{3}}}
;;...
;; doc-store
{1 "Bob" 2 :person/eats 3 "Spaghetti"}
```
the type of the maps/sets would depend on the algorithm we want to use. For hash join standard Clojure hashmaps and -sets
would be sufficient. For a WCOJ algorithm we need something that supports `seek` (see the mentions above).
A simplified transaction function could then look something along the lines of
```clj
(defrecord MemoryGraph [eav eva ave aev vea vae doc-store opts]
  ...
  )

(defn index-triple-add [graph [e a v :as triple]]
  (let [[he ha hv] (map hash triple)]
    (-> graph
        (update-in [:eav he ha] (fnil conj #{}) hv)
        (update-in [:eva he hv] (fnil conj #{}) ha)
        (update-in [:ave ha hv] (fnil conj #{}) he)
        (update-in [:aev ha he] (fnil conj #{}) hv)
        (update-in [:vea hv he] (fnil conj #{}) ha)
        (update-in [:vae hv ha] (fnil conj #{}) he)
        (update :doc-store into [[he e] [ha a] [hv v]]))))
```
I am saying "simplified" because you might want to use a more robust `hash` fn, make sure that
your `update-in` also creates non-standard intermediate maps (if non-existant) and maybe
switch out the bottom `#{}` for a more specific implementation.

### Iterators

### A simple datalog engine

### Abstracting more

Once you start implementing the algorithm outlined above you realize that it
quickly becomes very gnarly as there is the need for a lot of bookkeeping.
Whery am I currently for which operator


### A (simplified) proof

So far I mainly talked about implementation details and but have not given you any "proof"
that what we have built so far actually works in the desired runtime.

### Comparing different join algorithms

### Final remarks

You can find some of the ideas explained above implemented (although rather poorly tested)
at the [following](https://github.com/FiV0/hooray) repository.

### Appendix (general Formula)

### References

- The [slides](https://slides.com/fiv0/deck) of a talk about WCOJ I gave at the local Berlin Clojure meetup.
- AGM bound [https://arxiv.org/pdf/1711.03860.pdf](https://arxiv.org/pdf/1711.03860.pdf). The paper is not itself about
WCOJ but contains the result about graphs that the triggered this whole research area.

The following are roughly in order of comprehensibility (modulo my subjectivity):
- [https://justinjaffray.com/a-gentle-ish-introduction-to-worst-case-optimal-joins/](https://justinjaffray.com/a-gentle-ish-introduction-to-worst-case-optimal-joins/)
- [http://www.frankmcsherry.org/dataflow/relational/join/2015/04/11/genericjoin.html](http://www.frankmcsherry.org/dataflow/relational/join/2015/04/11/genericjoin.html)
- Leapfrog Triejoin [https://arxiv.org/abs/1210.0481](https://arxiv.org/abs/1210.0481)
- Skew strikes back [https://arxiv.org/abs/1310.3314](https://arxiv.org/abs/1310.3314)
- Radix Triejoin [https://arxiv.org/abs/1912.12747](https://arxiv.org/abs/1912.12747)
- WCOJ review [https://arxiv.org/abs/1803.09930](https://arxiv.org/abs/1803.09930)
- Simpli-Squared [https://arxiv.org/abs/2111.00163](https://arxiv.org/abs/2111.00163)

- Lake/Mountain picture at the top from [Luca Bravo](https://unsplash.com/@lucabravo)
